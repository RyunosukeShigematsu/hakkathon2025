<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Coupons</title>
  <link rel="stylesheet" href="../style.css" />
</head>

<body>
  <h1>クーポン候補</h1>
  <p class="muted">3つの中から1つ選んでください。やり直しもできます。</p>

  <div class="toolbar">
    <button class="primary" id="regenBtn">候補をやり直す</button>
    <span id="retryCount" style="margin-left:10px; font-weight:bold; font-size:14px;"></span>
  </div>

  <div style="height:12px;"></div>
  <div id="grid" class="grid"></div>

  <script src="../app.js"></script>
  <script>
    requireLoginFromPages();

    const API_BASE = "https://shigematsu.nkmr.io/hakkathon2025/server/api";
    const API_CANDIDATES = `${API_BASE}/user_coupons_candidates.php`;

    // ★追加：ログ保存API
    const API_LOG = `${API_BASE}/user_coupon_choice_log_create.php`;

    // ★追加：ログ送信関数
    async function sendChoiceLog(userId, shownIds, selectedId) {
      try {
        await fetch(API_LOG, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            user_id: userId,
            shown_coupon_ids: shownIds,
            selected_coupon_id: selectedId
          })
        });
      } catch (e) {
        console.error("ログ送信失敗:", e);
      }
    }

    async function fetchCandidatesFromDB() {
      const res = await fetch(API_CANDIDATES, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({})
      });

      const text = await res.text();
      let json;
      try { json = JSON.parse(text); }
      catch {
        console.log("raw response:", text);
        throw new Error("サーバ応答が不正です（Network→Response確認）");
      }

      if (!res.ok || !json?.ok) throw new Error(json?.message ?? "取得失敗");
      return json.items ?? [];
    }

    function shuffle(arr) {
      const a = [...arr];
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    function consumeOneRetryOrThrow() {
      const d = loadMyData();

      if (!d?.isRetryActive) throw new Error("やり直しは利用できません");
      if ((d.retries ?? 0) <= 0) throw new Error("やり直し回数が残っていません");

      saveMyData(x => {
        x.retries = (x.retries ?? 0) - 1;
        if (x.retries <= 0) {
          x.retries = 0;
          x.isRetryActive = false;
        }
        return x;
      });
    }

    function ensureThree(list) {
      const out = [...list];
      let n = 1;
      while (out.length < 3) {
        out.push({
          id: `dummy_${n++}`,
          shopName: `仮店舗${out.length + 1}`,
          menuName: `割引対象メニュー${out.length + 1}`,
          discountLabel: `${10 * (out.length + 1)}% OFF`,
          imageUrl: null,
          isDummy: true
        });
      }
      return out.slice(0, 3);
    }

    async function buildCandidates() {
      const items = await fetchCandidatesFromDB();

      const normalized = (items || []).map(x => ({
        id: x.id,
        shopName: x.shopName ?? "店舗",
        menuName: x.menuName ?? "対象メニュー",
        discountLabel: x.discountLabel ?? "",
        imageUrl: x.imageUrl ?? null,
        isDummy: false
      }));

      return ensureThree(shuffle(normalized));
    }

    function updateRetryDisplay() {
      const d = loadMyData();
      const retryEl = qs("#retryCount");

      if (!d || !d.isRetryActive || (d.retries ?? 0) <= 0) {
        retryEl.textContent = "（やり直しは利用できません）";
        qs("#regenBtn").disabled = true;
        qs("#regenBtn").style.opacity = 0.5;
      } else {
        retryEl.textContent = `（残りやり直し回数: ${d.retries}回）`;
        qs("#regenBtn").disabled = false;
        qs("#regenBtn").style.opacity = 1;
      }
    }

    function render(candidates) {
      qs("#grid").innerHTML = candidates.map(c => `
        <div class="coupon">
          <strong>${c.shopName}</strong>

          <div style="margin:12px 0; border:1px solid #eee; border-radius:12px; height:120px; display:flex; align-items:center; justify-content:center; background:#fafafa; color:#999;">
            ${c.imageUrl
              ? `<img src="${c.imageUrl}" style="max-width:100%; max-height:100%; border-radius:12px;">`
              : `No Image`}
          </div>

          <div class="muted">対象メニュー: <strong>${c.menuName}</strong></div>
          <div style="font-size:18px; font-weight:bold; margin:8px 0;">
            ${c.discountLabel ?? ""}
          </div>

          <div class="toolbar">
            <button data-id="${c.id}" class="primary selectBtn">
              これにする
            </button>
          </div>
        </div>
      `).join("");

      qsa(".selectBtn").forEach(btn => {
        btn.addEventListener("click", () => {
          const id = btn.dataset.id;
          const picked = candidates.find(c => String(c.id) === String(id));
          if (!picked) return;

          // ★追加：ログ送信（選択）
          const userId = getUserId();
          const shownIds = candidates.filter(x => !x.isDummy).map(x => x.id);
          sendChoiceLog(userId, shownIds, picked.id);

          if (!picked.isDummy) {
            saveMyData(d => {
              d.selectedCouponIds = d.selectedCouponIds ?? [];
              if (!d.selectedCouponIds.includes(picked.id)) {
                d.selectedCouponIds.unshift(picked.id);
              }
              d.isRetryActive = false;
              d.retries = 0;
              return d;
            });
          }

          location.href = "home.html";
        });
      });
    }

    async function init() {
      try {
        const candidates = await buildCandidates();
        saveMyData(d => { d.candidates = candidates; return d; });
        render(candidates);
        updateRetryDisplay();
      } catch (e) {
        alert(e?.message ?? "初期表示に失敗しました（ダミー表示）");
        const candidates = ensureThree([]);
        saveMyData(d => { d.candidates = candidates; return d; });
        render(candidates);
        updateRetryDisplay();
      }
    }

    on("#regenBtn", "click", async () => {
      try {
        const current = loadMyData()?.candidates ?? [];

        // ★追加：やり直し時のNULLログ送信
        const userId = getUserId();
        const shownIds = current.filter(x => !x.isDummy).map(x => x.id);
        if (shownIds.length > 0) {
          sendChoiceLog(userId, shownIds, null);
        }

        consumeOneRetryOrThrow();
        const candidates = await buildCandidates();
        saveMyData(d => { d.candidates = candidates; return d; });
        render(candidates);
        updateRetryDisplay();
      } catch (e) {
        alert(e?.message ?? "やり直しに失敗しました");
        updateRetryDisplay();
      }
    });

    init();
  </script>
</body>
</html>